import produce, { isDraft, finishDraft, createDraft, setAutoFreeze } from 'immer-peasy';
import React, { createContext, useContext, useState, useRef, useEffect, useMemo } from 'react';
import shallowEqual from 'shallowequal';
import { compose, createStore as createStore$1, applyMiddleware } from 'redux';
import reduxThunk from 'redux-thunk';
import memoizerific from 'memoizerific';

var StoreContext = createContext();

var isStateObject = function isStateObject(x) {
  return x !== null && typeof x === 'object' && !Array.isArray(x);
};
var get = function get(path, target) {
  return path.reduce(function (acc, cur) {
    return isStateObject(acc) ? acc[cur] : undefined;
  }, target);
};
var set = function set(path, target, value) {
  path.reduce(function (acc, cur, idx) {
    if (idx + 1 === path.length) {
      acc[cur] = value;
    } else {
      acc[cur] = acc[cur] || {};
    }

    return acc[cur];
  }, target);
};

function createStoreStateHook(Context) {
  return function useStoreState(mapState, dependencies) {
    if (dependencies === void 0) {
      dependencies = [];
    }

    var store = useContext(Context);

    var _useState = useState(function () {
      return mapState(store.getState());
    }),
        state = _useState[0],
        setState = _useState[1];

    var _useState2 = useState(null),
        error = _useState2[0],
        setError = _useState2[1]; // As our effect only fires on mount and unmount it won't have the state
    // changes visible to it, therefore we use a mutable ref to track this.


    var stateRef = useRef(state); // Helps avoid firing of events when unsubscribed, i.e. unmounted

    var isActive = useRef(true); // Tracks when a hooked component is unmounting

    var unmounted = useRef(false); // Throwing the error inline allows error boundaries the opportunity to
    // catch the error

    if (error) {
      throw error;
    }

    useEffect(function () {
      isActive.current = true;

      var calculateState = function calculateState() {
        if (!isActive.current) {
          return;
        }

        try {
          var newState = mapState(store.getState());

          if (newState === stateRef.current || isStateObject(newState) && isStateObject(stateRef.current) && shallowEqual(newState, stateRef.current)) {
            // Do nothing
            return;
          }

          stateRef.current = newState;
          setState(function () {
            return stateRef.current;
          });
        } catch (err) {
          // see https://github.com/reduxjs/react-redux/issues/1179
          // There is a possibility mapState will fail as the props/state that
          // the component has received is stale. Therefore we will afford the
          // application a small window of opportunity, where if they unmount
          // the component or provide it with new "valid" props (which will
          // subsequently cause a refreshed subscription cycle) then we will not
          // throw an error.
          // This is by no means a robust solution. We should track the
          // associated issue in the hope for a more dependable solution.
          // Setting the listener as "inactive", this can only be changed if the
          // incoming dependencies are different (i.e. props have changed)
          isActive.current = false;
          setTimeout(function () {
            if (!unmounted.current && !isActive.current) {
              setError(err);
            }
          }, 200); // give a window of opportunity
        }
      };

      calculateState();
      var unsubscribe = store.subscribe(calculateState);
      return function () {
        isActive.current = false;
        unsubscribe();
      };
    }, dependencies); // This effect will set the ref value to indicate that the component has
    // unmounted

    useEffect(function () {
      return function () {
        unmounted.current = true;
      };
    }, []);
    return state;
  };
}
var useStoreState = createStoreStateHook(StoreContext);
function createStoreActionsHook(Context) {
  return function useStoreActions(mapActions) {
    var store = useContext(Context);
    return mapActions(store.dispatch);
  };
}
var useStoreActions = createStoreActionsHook(StoreContext);
function createStoreDispatchHook(Context) {
  return function useStoreDispatch() {
    var store = useContext(Context);
    return store.dispatch;
  };
}
var useStoreDispatch = createStoreDispatchHook(StoreContext);

var wrapWithWarning = function wrapWithWarning(prev, next, useImp) {
  var warned = false;
  return function useDeprecated() {
    if (process.env.NODE_ENV !== 'production' && !warned) {
      // eslint-disable-next-line no-console
      console.warn("easy-peasy: The \"" + prev + "\" hook has been deprecated. Please replace all instances with the \"" + next + "\" hook.");
      warned = true;
    }

    return useImp.apply(void 0, arguments);
  };
};

var useActions = wrapWithWarning('useActions', 'useStoreActions', useStoreActions);
var useDispatch = wrapWithWarning('useDispatch', 'useStoreDispatch', useStoreDispatch);
var useStore = wrapWithWarning('useStore', 'useStoreState', useStoreState);
function createTypedHooks() {
  return {
    useActions: useActions,
    useDispatch: useDispatch,
    useStore: useStore,
    useStoreActions: useStoreActions,
    useStoreDispatch: useStoreDispatch,
    useStoreState: useStoreState
  };
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var actionNameSymbol = 'ðŸ™ˆactionNameðŸ™ˆ';
var actionSymbol = 'ðŸ™ˆactionðŸ™ˆ';
var actionStateSymbol = 'ðŸ™ˆactionStateðŸ™ˆ';
var computedSymbol = 'ðŸ™ˆcomputedSymbolðŸ™ˆ';
var computedConfigSymbol = 'ðŸ™ˆcomputedConfigSymbolðŸ™ˆ';
var listenSymbol = 'ðŸ™ˆlistenðŸ™ˆ';
var metaSymbol = 'ðŸ™ˆmetaðŸ™ˆ';
var reducerSymbol = 'ðŸ™ˆreducerðŸ™ˆ';
var selectDependenciesSymbol = 'ðŸ™ˆselectDependenciesðŸ™ˆ';
var selectImpSymbol = 'ðŸ™ˆselectImpðŸ™ˆ';
var selectStateSymbol = 'ðŸ™ˆselectStateðŸ™ˆ';
var selectSymbol = 'ðŸ™ˆselectðŸ™ˆ';
var selectorSymbol = 'ðŸ™ˆselectorðŸ™ˆ';
var selectorConfigSymbol = 'ðŸ™ˆselectorConfigðŸ™ˆ';
var selectorStateSymbol = 'ðŸ™ˆselectorStateðŸ™ˆ';
var thunkSymbol = 'ðŸ™ˆthunkðŸ™ˆ';
var thunkStateSymbol = 'ðŸ™ˆthunkStateðŸ™ˆ';

var actionName = function actionName(action) {
  return action[actionNameSymbol];
};
var debug = function debug(state) {
  if (isDraft(state)) {
    var final = finishDraft(createDraft(state));
    return final;
  }

  return state;
};
var thunkStartName = function thunkStartName(action) {
  return action[actionNameSymbol] + "(started)";
};
var thunkCompleteName = function thunkCompleteName(action) {
  return action[actionNameSymbol] + "(completed)";
};
var thunkFailName = function thunkFailName(action) {
  return action[actionNameSymbol] + "(failed)";
};
var action = function action(fn, config) {
  fn[actionSymbol] = true;
  fn[actionStateSymbol] = {
    config: config
  };
  return fn;
};
var defaultStateResolvers = [function (state) {
  return state;
}];
var computed = function computed(fn, stateResolvers) {
  if (stateResolvers === void 0) {
    stateResolvers = defaultStateResolvers;
  }

  fn[computedSymbol] = true;
  fn[computedConfigSymbol] = {
    stateResolvers: stateResolvers
  };
  return fn;
};
var listen = function listen(fn) {
  fn[listenSymbol] = true;
  return fn;
};
var memo = function memo(fn, cacheSize) {
  return memoizerific(cacheSize)(fn);
};
var thunk = function thunk(fn, config) {
  fn[thunkSymbol] = true;
  fn[thunkStateSymbol] = {
    config: config
  };
  return fn;
};
var select = function select(fn, dependencies) {
  fn[selectSymbol] = true;
  fn[selectDependenciesSymbol] = dependencies;
  fn[selectStateSymbol] = {};
  return fn;
};
var selector = function selector(args, fn, config) {
  fn[selectorSymbol] = true;
  fn[selectorConfigSymbol] = {
    args: args,
    config: config
  };
  return fn;
};
var reducer = function reducer(fn) {
  fn[reducerSymbol] = true;
  return fn;
};

var maxSelectFnMemoize = 100;

var tick = function tick() {
  return new Promise(function (resolve) {
    return setTimeout(resolve);
  });
};

var errorToPayload = function errorToPayload(err) {
  if (err instanceof Error) {
    return {
      message: err.message,
      stack: err.stack
    };
  }

  if (typeof err === 'string') {
    return err;
  }

  return undefined;
};

function createStoreInternals(_ref) {
  var disableInternalSelectFnMemoize = _ref.disableInternalSelectFnMemoize,
      initialState = _ref.initialState,
      injections = _ref.injections,
      model = _ref.model,
      reducerEnhancer = _ref.reducerEnhancer,
      references = _ref.references;
  var isInReducer = false;

  var wrapFnWithMemoize = function wrapFnWithMemoize(x) {
    return !disableInternalSelectFnMemoize && typeof x === 'function' ? memoizerific(maxSelectFnMemoize)(x) : x;
  };

  var defaultState = initialState || {};
  var selectorId = 0;
  var computedProperties = {};
  var actionCreatorDict = {};
  var actionCreators = {};
  var actionListenersDict = {};
  var actionReducersDict = {};
  var actionThunks = {};
  var customReducers = [];
  var listenDefinitions = [];
  var listenerActionDefinitions = [];
  var listenerActionMap = {};
  var listenerThunkMap = {};
  var selectorsDict = {};
  var selectorReducers = [];
  var thunkListenersDict = {};

  var recursiveExtractDefsFromModel = function recursiveExtractDefsFromModel(current, parentPath) {
    return Object.keys(current).forEach(function (key) {
      var value = current[key];
      var path = [].concat(parentPath, [key]);
      var meta = {
        parent: parentPath,
        path: path
      };

      if (typeof value === 'function') {
        if (value[actionSymbol]) {
          var name = "@action." + path.join('.');
          value[actionNameSymbol] = name;
          value[metaSymbol] = meta; // Action Reducer

          var actionReducer = value;
          actionReducer[actionNameSymbol] = name;
          actionReducersDict[name] = actionReducer;

          var actionCreator = function actionCreator(payload) {
            var result = references.dispatch({
              type: actionReducer[actionNameSymbol],
              payload: payload
            });
            return result;
          };

          actionCreator[actionNameSymbol] = name;
          actionCreatorDict[name] = actionCreator;
          set(path, actionCreators, actionCreator);
          var config = value[actionStateSymbol].config;

          if (config && config.listenTo) {
            listenerActionDefinitions.push(value);
          }
        } else if (value[thunkSymbol]) {
          var _name = "@thunk." + path.join('.');

          value[actionNameSymbol] = _name; // Thunk Action

          var action = function action(payload) {
            return value(get(parentPath, actionCreators), payload, {
              // @deprecated
              dispatch: references.dispatch,
              getState: function getState() {
                return get(parentPath, references.getState());
              },
              getStoreActions: function getStoreActions() {
                return actionCreators;
              },
              getStoreState: references.getState,
              injections: injections,
              meta: meta
            });
          };

          set(path, actionThunks, action); // Thunk Action Creator

          var _actionCreator = function _actionCreator(payload) {
            return tick().then(function () {
              return references.dispatch({
                type: _name + "(started)",
                payload: payload
              });
            }).then(function () {
              return references.dispatch(function () {
                return action(payload);
              });
            }).then(function (result) {
              references.dispatch({
                type: _name + "(completed)",
                payload: payload
              });
              return result;
            }).catch(function (err) {
              references.dispatch({
                type: _name + "(failed)",
                payload: payload,
                error: errorToPayload(err)
              });
              throw err;
            });
          };

          _actionCreator[actionNameSymbol] = _name;
          actionCreatorDict[_name] = _actionCreator;
          set(path, actionCreators, _actionCreator);
          var _config = value[thunkStateSymbol].config;

          if (_config && _config.listenTo) {
            listenerActionDefinitions.push(value);
          }
        } else if (value[computedSymbol]) {
          var target = get(parentPath, defaultState);

          if (!target) {
            target = {};
            set(parentPath, defaultState, target);
          }

          var _config2 = value[computedConfigSymbol];
          var stateResolvers = _config2.stateResolvers;
          var memoisedResultFn = memoizerific(1)(value);
          var cache;

          var createComputedProperty = function createComputedProperty(o) {
            Object.defineProperty(o, key, {
              configurable: true,
              get: function get$1() {
                var storeState = isInReducer ? references.currentState : references.getState();

                var state = get(parentPath, storeState);

                var inputs = stateResolvers.map(function (resolver) {
                  return resolver(state, storeState);
                });
                cache = memoisedResultFn.apply(void 0, inputs);
                return cache;
              },
              set: function set() {
                throw new Error("Easy Peasy: You attempted to set \"" + path.join('.') + "\", which is a computed property set a computed property");
              }
            });
          };

          createComputedProperty(target);
          set(path, computedProperties, createComputedProperty);
        } else if (value[selectorSymbol]) {
          selectorId += 1;
          var selectorInstanceId = selectorId;
          var _value$selectorConfig = value[selectorConfigSymbol],
              args = _value$selectorConfig.args,
              _config3 = _value$selectorConfig.config;
          var stateSelectors = args && Array.isArray(args) ? args.map(function (s) {
            return memoizerific(1)(s);
          }) : [function (state) {
            return state;
          }];
          var limit = typeof _config3 === 'object' && typeof _config3.limit === 'number' && _config3.limit > 0 ? _config3.number : 1;
          var internalSelector = memoizerific(limit)(function () {
            for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {
              a[_key] = arguments[_key];
            }

            return value(a.slice(0, stateSelectors.length), a.slice(stateSelectors.length));
          });
          var changeIdx = 0;
          /**
           * This allows us to track whether the state we are depending on
           * (resolved via the state selectors), has changed. If so then we know
           * that we should create a new instance of our selector function so
           * that updates are propagated and memoization caches are cleared.
           */

          var createDependentStateChangeTracker = function createDependentStateChangeTracker() {
            var internalChecker = memoizerific(1)(function () {
              changeIdx += 1;
              return changeIdx;
            });

            var dependentStateChangeTracker = function dependentStateChangeTracker(storeState) {
              var localState = get(parentPath, storeState);

              var resolvedStateArgs = stateSelectors.reduce(function (acc, argSelector) {
                acc.push(argSelector(localState, storeState));
                return acc;
              }, []);
              return internalChecker.apply(void 0, resolvedStateArgs);
            };

            return dependentStateChangeTracker;
          };
          /**
           * We create a function allowing us to create new selector instances.
           * We will need this ability to reinitialise a selector of the state
           * it depends on changes.
           */


          var createSelector = function createSelector() {
            var selector = function selector() {
              var storeState = references.getState();

              var localState = get(parentPath, storeState);

              var selectedStateArgs = stateSelectors.reduce(function (acc, argSelector) {
                return [].concat(acc, [argSelector(localState, storeState)]);
              }, []);

              for (var _len2 = arguments.length, runtimeArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                runtimeArgs[_key2] = arguments[_key2];
              }

              return internalSelector.apply(void 0, selectedStateArgs.concat(runtimeArgs));
            };

            selector[selectorStateSymbol] = {
              dependentStateChangeTracker: createDependentStateChangeTracker(),
              createSelector: createSelector,
              meta: meta,
              selectorId: selectorInstanceId
            };
            return selector;
          };

          var selector = createSelector();
          selectorsDict[selectorId] = selector;
          set(path, defaultState, selector);
        } else if (value[selectSymbol]) {
          value[selectStateSymbol] = {
            parentPath: parentPath,
            key: key,
            executed: false
          };
          selectorReducers.push(value);
        } else if (value[reducerSymbol]) {
          customReducers.push({
            path: path,
            reducer: value
          });
        } else if (value[listenSymbol]) {
          listenDefinitions.push(value);
          value[metaSymbol] = meta;
        } else if (process.env.NODE_ENV !== 'production') {
          // eslint-disable-next-line no-console
          console.warn("easy-peasy: Found a function at path " + path.join('.') + " in your model. Version 2 required that you wrap your action functions with the \"action\" helper");
        }
      } else if (isStateObject(value) && Object.keys(value).length > 0) {
        var existing = get(path, defaultState);

        if (existing == null) {
          set(path, defaultState, {});
        }

        recursiveExtractDefsFromModel(value, path);
      } else {
        // State
        var initialParentRef = get(parentPath, initialState);

        if (initialParentRef && key in initialParentRef) {
          set(path, defaultState, initialParentRef[key]);
        } else {
          set(path, defaultState, value);
        }
      }
    });
  };

  recursiveExtractDefsFromModel(model, []);
  listenerActionDefinitions.forEach(function (listenerAction) {
    var _ref2 = listenerAction[actionStateSymbol] || listenerAction[thunkStateSymbol],
        listenTo = _ref2.config.listenTo;

    var targetName;

    var processListenTo = function processListenTo(target) {
      if (typeof target === 'function' && target[actionNameSymbol] && actionCreatorDict[target[actionNameSymbol]]) {
        if (target[thunkSymbol]) {
          targetName = thunkCompleteName(target);
        } else {
          targetName = target[actionNameSymbol];
        }
      } else if (typeof target === 'string') {
        targetName = target;
      }

      var listenerReg = listenerActionMap[targetName] || [];
      listenerReg.push(actionCreatorDict[listenerAction[actionNameSymbol]]);
      listenerActionMap[targetName] = listenerReg;
    };

    if (Array.isArray(listenTo)) {
      listenTo.forEach(processListenTo);
    } else {
      processListenTo(listenTo);
    }
  });
  selectorReducers.forEach(function (selector) {
    selector[selectImpSymbol] = function (state) {
      return wrapFnWithMemoize(selector(state));
    };
  });
  listenDefinitions.forEach(function (def) {
    def.listeners = def.listeners || {};

    var on = function on(target, handler) {
      if (typeof handler !== 'function') {
        return;
      }

      var meta = def[metaSymbol];
      handler[metaSymbol] = meta;

      if (!handler[actionSymbol] && !handler[thunkSymbol]) {
        if (process.env.NODE_ENV !== 'production') {
          // eslint-disable-next-line
          console.warn("easy-peasy: you must provide either an \"action\" or \"thunk\" to your listeners. Found an invalid handler at \"" + meta.path.join('.') + "\"");
        }

        return;
      }

      var targetActionName;

      if (typeof target === 'function' && target[actionNameSymbol] && actionCreatorDict[target[actionNameSymbol]]) {
        if (target[thunkSymbol]) {
          targetActionName = thunkCompleteName(target);
        } else {
          targetActionName = target[actionNameSymbol];
        }
      } else if (typeof target === 'string') {
        targetActionName = target;
      }

      if (targetActionName) {
        if (handler[thunkSymbol]) {
          thunkListenersDict[targetActionName] = thunkListenersDict[targetActionName] || [];
          thunkListenersDict[targetActionName].push(handler);
        } else {
          actionListenersDict[targetActionName] = actionListenersDict[targetActionName] || [];
          actionListenersDict[targetActionName].push({
            path: meta.parent,
            handler: handler
          });
        }

        def.listeners[targetActionName] = def.listeners[targetActionName] || [];
        def.listeners[targetActionName].push(handler);
      }
    };

    def(on);
  });

  var runSelectorReducer = function runSelectorReducer(state, selector) {
    var _selector$selectState = selector[selectStateSymbol],
        parentPath = _selector$selectState.parentPath,
        key = _selector$selectState.key,
        executed = _selector$selectState.executed;

    if (executed) {
      return state;
    }

    var dependencies = selector[selectDependenciesSymbol];
    var stateAfterDependencies = dependencies ? dependencies.reduce(runSelectorReducer, state) : state;
    var newState = stateAfterDependencies;

    if (parentPath.length > 0) {
      var target = get(parentPath, stateAfterDependencies);

      if (target) {
        if (!selector.prevState || selector.prevState !== get(parentPath, state)) {
          var newValue = selector[selectImpSymbol](target);
          newState = produce(state, function (draft) {
            var updateTarget = get(parentPath, draft);

            updateTarget[key] = newValue;
          });
          selector.prevState = get(parentPath, newState);
        }
      }
    } else if (!selector.prevState || selector.prevState !== state) {
      var _newValue = selector[selectImpSymbol](stateAfterDependencies);

      newState = produce(state, function (draft) {
        draft[key] = _newValue;
      });
      selector.prevState = newState;
    }

    selector[selectStateSymbol].executed = true;
    return newState;
  };

  var runSelectors = function runSelectors(state) {
    return selectorReducers.reduce(runSelectorReducer, state);
  };

  var createReducer = function createReducer() {
    var runActionReducerAtPath = function runActionReducerAtPath(state, action, actionReducer, path) {
      var current = get(path, state);

      var updatedState = path.length === 0 ? produce(state, function (_draft) {
        return actionReducer(_draft, action.payload);
      }) : produce(state, function (draft) {
        set(actionReducer[metaSymbol].parent, draft, produce(current, function (_draft) {
          return actionReducer(_draft, action.payload);
        }));
      });

      if (updatedState !== state) {
        var computedPropertyCreators = get(path, computedProperties);

        if (computedPropertyCreators) {
          var updatedCurrent = get(path, updatedState);

          Object.keys(computedPropertyCreators).forEach(function (key) {
            computedPropertyCreators[key](updatedCurrent);
          });
        }
      }

      return updatedState;
    };

    var reducerForActions = function reducerForActions(state, action) {
      var actionReducer = actionReducersDict[action.type];

      if (actionReducer) {
        return runActionReducerAtPath(state, action, actionReducer, actionReducer[metaSymbol].parent);
      }

      return state;
    };

    var reducerForListeners = function reducerForListeners(state, action) {
      var target = action.type === '@@EP/LISTENER' ? action.actionName : action.type;
      var actionListeners = actionListenersDict[target];

      if (actionListeners) {
        var targetAction = action.type === '@@EP/LISTENER' ? {
          type: target,
          payload: action.payload
        } : action;
        return actionListeners.reduce(function (newState, _ref3) {
          var path = _ref3.path,
              handler = _ref3.handler;
          return runActionReducerAtPath(newState, targetAction, handler, path);
        }, state);
      }

      return state;
    };

    var reducerForCustomReducers = function reducerForCustomReducers(state, action) {
      return produce(state, function (draft) {
        customReducers.forEach(function (_ref4) {
          var p = _ref4.path,
              red = _ref4.reducer;

          var current = get(p, draft);

          set(p, draft, red(current, action));
        });
      });
    };

    var isInitial = true;

    var selectsReducer = function selectsReducer(state) {
      var stateAfterSelectors = runSelectors(state);
      isInitial = false;
      selectorReducers.forEach(function (selector) {
        selector[selectStateSymbol].executed = false;
      });
      return stateAfterSelectors;
    };

    var selectorsReducer = function selectorsReducer(state) {
      var selectors = Object.values(selectorsDict);
      return produce(state, function (draft) {
        selectors.forEach(function (selector) {
          var selectorState = selector[selectorStateSymbol];

          if (selectorState.prevStateCheckId == null) {
            selectorState.prevStateCheckId = selectorState.dependentStateChangeTracker(state);
          } else {
            var nextStateCheckId = selectorState.dependentStateChangeTracker(state);

            if (selectorState.prevStateCheckId !== nextStateCheckId) {
              var newSelector = selectorState.createSelector();
              newSelector[selectorState.prevStateCheckId] = nextStateCheckId;
              selectorsDict[selectorState.selectorId] = newSelector;
              set(selectorState.meta.path, draft, newSelector);
            }
          }
        });
      });
    };

    var rootReducer = function rootReducer(state, action) {
      isInReducer = true;
      var stateAfterActions = reducerForActions(state, action);
      var stateAfterListeners = reducerForListeners(stateAfterActions, action);
      var stateAfterCustomReducers = reducerForCustomReducers(stateAfterListeners, action);
      var stateAfterSelect = state !== stateAfterCustomReducers || isInitial ? selectsReducer(stateAfterCustomReducers) : stateAfterCustomReducers;
      var result = selectorsReducer(stateAfterSelect);
      isInReducer = false;
      return result;
    };

    return rootReducer;
  };

  return {
    actionCreators: actionCreators,
    actionListenersDict: actionListenersDict,
    defaultState: defaultState,
    listenDefinitions: listenDefinitions,
    listenerActionMap: listenerActionMap,
    listenerThunkMap: listenerThunkMap,
    reducer: reducerEnhancer(createReducer()),
    thunkListenersDict: thunkListenersDict
  };
}

function createStore(model, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      compose$1 = _options.compose,
      _options$devTools = _options.devTools,
      devTools = _options$devTools === void 0 ? true : _options$devTools,
      _options$disableInter = _options.disableInternalSelectFnMemoize,
      disableInternalSelectFnMemoize = _options$disableInter === void 0 ? false : _options$disableInter,
      _options$enhancers = _options.enhancers,
      enhancers = _options$enhancers === void 0 ? [] : _options$enhancers,
      _options$initialState = _options.initialState,
      initialState = _options$initialState === void 0 ? {} : _options$initialState,
      injections = _options.injections,
      _options$middleware = _options.middleware,
      middleware = _options$middleware === void 0 ? [] : _options$middleware,
      _options$mockActions = _options.mockActions,
      mockActions = _options$mockActions === void 0 ? false : _options$mockActions,
      _options$name = _options.name,
      storeName = _options$name === void 0 ? "EasyPeasyStore" : _options$name,
      _options$reducerEnhan = _options.reducerEnhancer,
      reducerEnhancer = _options$reducerEnhan === void 0 ? function (rootReducer) {
    return rootReducer;
  } : _options$reducerEnhan;

  var modelDefinition = _extends({}, model, {
    logFullState: thunk(function (actions, payload, _ref) {
      var getState = _ref.getState;
      // eslint-disable-next-line no-console
      console.log(JSON.stringify(getState(), null, 2));
    }),
    replaceState: action(function (state, payload) {
      return payload;
    })
  });

  var references = {};
  var mockedActions = [];

  var dispatchThunk = function dispatchThunk(thunk, payload) {
    return thunk(get(thunk[metaSymbol].parent, references.internals.actionCreators), payload, {
      dispatch: references.dispatch,
      getState: function getState() {
        return get(thunk[metaSymbol].parent, references.getState());
      },
      getStoreState: references.getState,
      injections: injections,
      meta: thunk[metaSymbol]
    });
  };

  var dispatchThunkListeners = function dispatchThunkListeners(name, payload) {
    var listensForAction = references.internals.thunkListenersDict[name];
    return listensForAction && listensForAction.length > 0 ? Promise.all(listensForAction.map(function (listenForAction) {
      return dispatchThunk(listenForAction, payload);
    })) : Promise.resolve();
  };

  var dispatchActionStringListeners = function dispatchActionStringListeners() {
    return function (next) {
      return function (action) {
        var result = next(action);

        if (references.internals.thunkListenersDict[action.type]) {
          dispatchThunkListeners(action.type, action.payload);
        }

        return result;
      };
    };
  };

  var composeEnhancers = compose$1 || (devTools && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
    name: storeName
  }) : compose);

  var bindStoreInternals = function bindStoreInternals(state) {
    references.internals = createStoreInternals({
      disableInternalSelectFnMemoize: disableInternalSelectFnMemoize,
      initialState: state,
      injections: injections,
      model: modelDefinition,
      reducerEnhancer: reducerEnhancer,
      references: references
    });
  };

  bindStoreInternals(initialState);

  var listenerActionsMiddleware = function listenerActionsMiddleware() {
    return function (next) {
      return function (action) {
        var result = next(action);

        if (action && references.internals.listenerActionMap[action.type] && references.internals.listenerActionMap[action.type].length > 0) {
          references.internals.listenerActionMap[action.type].forEach(function (actionCreator) {
            actionCreator(action.payload);
          });
        }

        return result;
      };
    };
  };

  var mockActionsMiddleware = function mockActionsMiddleware() {
    return function (next) {
      return function (action) {
        if (mockActions) {
          if (action == null || typeof action === 'object' && action.type === '@@EP/LISTENER') ; else {
            mockedActions.push(action);
          }

          return undefined;
        }

        return next(action);
      };
    };
  };

  var currentStateMiddleware = function currentStateMiddleware() {
    return function (next) {
      return function (action) {
        references.currentState = references.getState();
        return next(action);
      };
    };
  };

  var store = createStore$1(references.internals.reducer, references.internals.defaultState, composeEnhancers.apply(void 0, [applyMiddleware.apply(void 0, [reduxThunk, dispatchActionStringListeners].concat(middleware, [listenerActionsMiddleware, currentStateMiddleware, mockActionsMiddleware]))].concat(enhancers)));

  store.getMockedActions = function () {
    return [].concat(mockedActions);
  };

  store.clearMockedActions = function () {
    mockedActions = [];
  };

  references.dispatch = store.dispatch;
  references.getState = store.getState; // attach the action creators to dispatch

  var bindActionCreators = function bindActionCreators(actionCreators) {
    Object.keys(store.dispatch).forEach(function (actionsKey) {
      delete store.dispatch[actionsKey];
    });
    Object.keys(actionCreators).forEach(function (key) {
      store.dispatch[key] = actionCreators[key];
    });

    store.getActions = function () {
      return actionCreators;
    };
  };

  bindActionCreators(references.internals.actionCreators);

  var rebindStore = function rebindStore(removeKey) {
    var currentState = store.getState();

    if (removeKey) {
      delete currentState[removeKey];
    }

    bindStoreInternals(store.getState());
    store.replaceReducer(references.internals.reducer);
    store.dispatch.replaceState(references.internals.defaultState);
    bindActionCreators(references.internals.actionCreators);
  };

  store.addModel = function (key, modelForKey) {
    if (modelDefinition[key] && process.env.NODE_ENV !== 'production') {
      // eslint-disable-next-line no-console
      console.warn("easy-peasy: The store model already contains a model definition for \"" + key + "\"");
      store.removeModel(key);
    }

    modelDefinition[key] = modelForKey;
    rebindStore();
  };

  store.removeModel = function (key) {
    if (!modelDefinition[key]) {
      if (process.env.NODE_ENV !== 'production') {
        // eslint-disable-next-line no-console
        console.warn("easy-peasy: The store model does not contain a model definition for \"" + key + "\"");
      }

      return;
    }

    delete modelDefinition[key];
    rebindStore(key);
  }; // @deprecated


  var dispatchActionListener = function dispatchActionListener(actionName, payload) {
    return store.dispatch({
      type: '@@EP/LISTENER',
      payload: payload,
      actionName: actionName
    });
  };

  var resolveActionName = function resolveActionName(action) {
    return typeof action === 'function' ? action[actionSymbol] ? actionName(action) : action[thunkSymbol] ? thunkCompleteName(action) : undefined : typeof action === 'string' ? action : undefined;
  }; // @deprecated


  store.triggerListener = function (listener, action, payload) {
    var actionName = resolveActionName(action);

    if (listener.listeners[actionName] && listener.listeners[actionName].length > 0) {
      if (listener.listeners[actionName].some(function (handler) {
        return handler[actionSymbol];
      })) {
        dispatchActionListener(actionName, payload);
      }

      var thunkHandlers = listener.listeners[actionName].filter(function (handler) {
        return handler[thunkSymbol];
      });
      return thunkHandlers.length > 0 ? Promise.all(thunkHandlers.map(function (handler) {
        return dispatchThunk(handler, payload);
      })).then(function () {
        return undefined;
      }) : Promise.resolve();
    }

    return Promise.resolve();
  }; // @deprecated


  store.triggerListeners = function (action, payload) {
    var actionName = resolveActionName(action);

    if (actionName) {
      var actionListenerHandlers = references.internals.actionListenersDict[actionName];

      if (actionListenerHandlers && actionListenerHandlers.length > 0) {
        dispatchActionListener(actionName, payload);
      }

      var thunkListenerHandlers = references.internals.thunkListenersDict[actionName];
      return thunkListenerHandlers && thunkListenerHandlers.length > 0 ? Promise.all(thunkListenerHandlers.map(function (handler) {
        return dispatchThunk(handler, payload);
      })).then(function () {
        return undefined;
      }) : Promise.resolve();
    }

    return Promise.resolve();
  };

  store.useStoreActions = useStoreActions;
  store.useStoreDispatch = useStoreDispatch;
  store.useStoreState = useStoreState;
  return store;
}

/* eslint-disable react/prop-types */
function createContextStore(model, config) {
  var StoreContext = createContext();

  function Provider(_ref) {
    var children = _ref.children,
        initialData = _ref.initialData;
    var store = useMemo(function () {
      return createStore(typeof model === 'function' ? model(initialData) : model, config);
    }, []);
    return React.createElement(StoreContext.Provider, {
      value: store
    }, children);
  }

  function useStore() {
    return useContext(StoreContext);
  }

  return {
    Provider: Provider,
    useStore: useStore,
    useStoreState: createStoreStateHook(StoreContext),
    useStoreActions: createStoreActionsHook(StoreContext),
    useStoreDispatch: createStoreDispatchHook(StoreContext)
  };
}

/**
 * Some good references on the topic of reinitialisation:
 * - https://github.com/facebook/react/issues/14830
 */

function createComponentStore(model, config) {
  return function useLocalStore(initialData) {
    var store = useMemo(function () {
      return createStore(typeof model === 'function' ? model(initialData) : model, config);
    }, []);
    var previousStateRef = useRef(store.getState());

    var _useState = useState(function () {
      return store.getState();
    }),
        currentState = _useState[0],
        setCurrentState = _useState[1];

    useEffect(function () {
      return store.subscribe(function () {
        var nextState = store.getState();

        if (previousStateRef.current !== nextState) {
          previousStateRef.current = nextState;
          setCurrentState(nextState);
        }
      });
    }, [store]);
    return [currentState, store.dispatch];
  };
}

var StoreProvider = function StoreProvider(_ref) {
  var children = _ref.children,
      store = _ref.store;
  return React.createElement(StoreContext.Provider, {
    value: store
  }, children);
};

/**
 * immer is an implementation detail, so we are not going to use its auto freeze
 * behaviour, which throws errors if trying to mutate state. It's also risky
 * for production builds as has a perf overhead.
 *
 * @see https://github.com/mweststrate/immer#auto-freezing
 */

setAutoFreeze(false);

export { StoreProvider, action, actionName, computed, createComponentStore, createContextStore, createStore, createTypedHooks, debug, listen, memo, reducer, select, selector, thunk, thunkCompleteName, thunkFailName, thunkStartName, useActions, useDispatch, useStore, useStoreActions, useStoreDispatch, useStoreState };
//# sourceMappingURL=easy-peasy.esm.js.map
