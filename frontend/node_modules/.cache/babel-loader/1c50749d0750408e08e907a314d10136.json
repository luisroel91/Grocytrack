{"ast":null,"code":"import produce, { isDraft, finishDraft, createDraft, setAutoFreeze } from 'immer-peasy';\nimport React, { createContext, useContext, useState, useRef, useEffect, useMemo } from 'react';\nimport shallowEqual from 'shallowequal';\nimport { compose, createStore as createStore$1, applyMiddleware } from 'redux';\nimport reduxThunk from 'redux-thunk';\nimport memoizerific from 'memoizerific';\nvar StoreContext = createContext();\n\nvar isStateObject = function isStateObject(x) {\n  return x !== null && typeof x === 'object' && !Array.isArray(x);\n};\n\nvar get = function get(path, target) {\n  return path.reduce(function (acc, cur) {\n    return isStateObject(acc) ? acc[cur] : undefined;\n  }, target);\n};\n\nvar set = function set(path, target, value) {\n  path.reduce(function (acc, cur, idx) {\n    if (idx + 1 === path.length) {\n      acc[cur] = value;\n    } else {\n      acc[cur] = acc[cur] || {};\n    }\n\n    return acc[cur];\n  }, target);\n};\n\nfunction createStoreStateHook(Context) {\n  return function useStoreState(mapState, dependencies) {\n    if (dependencies === void 0) {\n      dependencies = [];\n    }\n\n    var store = useContext(Context);\n\n    var _useState = useState(function () {\n      return mapState(store.getState());\n    }),\n        state = _useState[0],\n        setState = _useState[1];\n\n    var _useState2 = useState(null),\n        error = _useState2[0],\n        setError = _useState2[1]; // As our effect only fires on mount and unmount it won't have the state\n    // changes visible to it, therefore we use a mutable ref to track this.\n\n\n    var stateRef = useRef(state); // Helps avoid firing of events when unsubscribed, i.e. unmounted\n\n    var isActive = useRef(true); // Tracks when a hooked component is unmounting\n\n    var unmounted = useRef(false); // Throwing the error inline allows error boundaries the opportunity to\n    // catch the error\n\n    if (error) {\n      throw error;\n    }\n\n    useEffect(function () {\n      isActive.current = true;\n\n      var calculateState = function calculateState() {\n        if (!isActive.current) {\n          return;\n        }\n\n        try {\n          var newState = mapState(store.getState());\n\n          if (newState === stateRef.current || isStateObject(newState) && isStateObject(stateRef.current) && shallowEqual(newState, stateRef.current)) {\n            // Do nothing\n            return;\n          }\n\n          stateRef.current = newState;\n          setState(function () {\n            return stateRef.current;\n          });\n        } catch (err) {\n          // see https://github.com/reduxjs/react-redux/issues/1179\n          // There is a possibility mapState will fail as the props/state that\n          // the component has received is stale. Therefore we will afford the\n          // application a small window of opportunity, where if they unmount\n          // the component or provide it with new \"valid\" props (which will\n          // subsequently cause a refreshed subscription cycle) then we will not\n          // throw an error.\n          // This is by no means a robust solution. We should track the\n          // associated issue in the hope for a more dependable solution.\n          // Setting the listener as \"inactive\", this can only be changed if the\n          // incoming dependencies are different (i.e. props have changed)\n          isActive.current = false;\n          setTimeout(function () {\n            if (!unmounted.current && !isActive.current) {\n              setError(err);\n            }\n          }, 200); // give a window of opportunity\n        }\n      };\n\n      calculateState();\n      var unsubscribe = store.subscribe(calculateState);\n      return function () {\n        isActive.current = false;\n        unsubscribe();\n      };\n    }, dependencies); // This effect will set the ref value to indicate that the component has\n    // unmounted\n\n    useEffect(function () {\n      return function () {\n        unmounted.current = true;\n      };\n    }, []);\n    return state;\n  };\n}\n\nvar useStoreState = createStoreStateHook(StoreContext);\n\nfunction createStoreActionsHook(Context) {\n  return function useStoreActions(mapActions) {\n    var store = useContext(Context);\n    return mapActions(store.dispatch);\n  };\n}\n\nvar useStoreActions = createStoreActionsHook(StoreContext);\n\nfunction createStoreDispatchHook(Context) {\n  return function useStoreDispatch() {\n    var store = useContext(Context);\n    return store.dispatch;\n  };\n}\n\nvar useStoreDispatch = createStoreDispatchHook(StoreContext);\n\nvar wrapWithWarning = function wrapWithWarning(prev, next, useImp) {\n  var warned = false;\n  return function useDeprecated() {\n    if (process.env.NODE_ENV !== 'production' && !warned) {\n      // eslint-disable-next-line no-console\n      console.warn(\"easy-peasy: The \\\"\" + prev + \"\\\" hook has been deprecated. Please replace all instances with the \\\"\" + next + \"\\\" hook.\");\n      warned = true;\n    }\n\n    return useImp.apply(void 0, arguments);\n  };\n};\n\nvar useActions = wrapWithWarning('useActions', 'useStoreActions', useStoreActions);\nvar useDispatch = wrapWithWarning('useDispatch', 'useStoreDispatch', useStoreDispatch);\nvar useStore = wrapWithWarning('useStore', 'useStoreState', useStoreState);\n\nfunction createTypedHooks() {\n  return {\n    useActions: useActions,\n    useDispatch: useDispatch,\n    useStore: useStore,\n    useStoreActions: useStoreActions,\n    useStoreDispatch: useStoreDispatch,\n    useStoreState: useStoreState\n  };\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar actionNameSymbol = 'ðŸ™ˆactionNameðŸ™ˆ';\nvar actionSymbol = 'ðŸ™ˆactionðŸ™ˆ';\nvar actionStateSymbol = 'ðŸ™ˆactionStateðŸ™ˆ';\nvar computedSymbol = 'ðŸ™ˆcomputedSymbolðŸ™ˆ';\nvar computedConfigSymbol = 'ðŸ™ˆcomputedConfigSymbolðŸ™ˆ';\nvar listenSymbol = 'ðŸ™ˆlistenðŸ™ˆ';\nvar metaSymbol = 'ðŸ™ˆmetaðŸ™ˆ';\nvar reducerSymbol = 'ðŸ™ˆreducerðŸ™ˆ';\nvar selectDependenciesSymbol = 'ðŸ™ˆselectDependenciesðŸ™ˆ';\nvar selectImpSymbol = 'ðŸ™ˆselectImpðŸ™ˆ';\nvar selectStateSymbol = 'ðŸ™ˆselectStateðŸ™ˆ';\nvar selectSymbol = 'ðŸ™ˆselectðŸ™ˆ';\nvar selectorSymbol = 'ðŸ™ˆselectorðŸ™ˆ';\nvar selectorConfigSymbol = 'ðŸ™ˆselectorConfigðŸ™ˆ';\nvar selectorStateSymbol = 'ðŸ™ˆselectorStateðŸ™ˆ';\nvar thunkSymbol = 'ðŸ™ˆthunkðŸ™ˆ';\nvar thunkStateSymbol = 'ðŸ™ˆthunkStateðŸ™ˆ';\n\nvar actionName = function actionName(action) {\n  return action[actionNameSymbol];\n};\n\nvar debug = function debug(state) {\n  if (isDraft(state)) {\n    var final = finishDraft(createDraft(state));\n    return final;\n  }\n\n  return state;\n};\n\nvar thunkStartName = function thunkStartName(action) {\n  return action[actionNameSymbol] + \"(started)\";\n};\n\nvar thunkCompleteName = function thunkCompleteName(action) {\n  return action[actionNameSymbol] + \"(completed)\";\n};\n\nvar thunkFailName = function thunkFailName(action) {\n  return action[actionNameSymbol] + \"(failed)\";\n};\n\nvar action = function action(fn, config) {\n  fn[actionSymbol] = true;\n  fn[actionStateSymbol] = {\n    config: config\n  };\n  return fn;\n};\n\nvar defaultStateResolvers = [function (state) {\n  return state;\n}];\n\nvar computed = function computed(fn, stateResolvers) {\n  if (stateResolvers === void 0) {\n    stateResolvers = defaultStateResolvers;\n  }\n\n  fn[computedSymbol] = true;\n  fn[computedConfigSymbol] = {\n    stateResolvers: stateResolvers\n  };\n  return fn;\n};\n\nvar listen = function listen(fn) {\n  fn[listenSymbol] = true;\n  return fn;\n};\n\nvar memo = function memo(fn, cacheSize) {\n  return memoizerific(cacheSize)(fn);\n};\n\nvar thunk = function thunk(fn, config) {\n  fn[thunkSymbol] = true;\n  fn[thunkStateSymbol] = {\n    config: config\n  };\n  return fn;\n};\n\nvar select = function select(fn, dependencies) {\n  fn[selectSymbol] = true;\n  fn[selectDependenciesSymbol] = dependencies;\n  fn[selectStateSymbol] = {};\n  return fn;\n};\n\nvar selector = function selector(args, fn, config) {\n  fn[selectorSymbol] = true;\n  fn[selectorConfigSymbol] = {\n    args: args,\n    config: config\n  };\n  return fn;\n};\n\nvar reducer = function reducer(fn) {\n  fn[reducerSymbol] = true;\n  return fn;\n};\n\nvar maxSelectFnMemoize = 100;\n\nvar tick = function tick() {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve);\n  });\n};\n\nvar errorToPayload = function errorToPayload(err) {\n  if (err instanceof Error) {\n    return {\n      message: err.message,\n      stack: err.stack\n    };\n  }\n\n  if (typeof err === 'string') {\n    return err;\n  }\n\n  return undefined;\n};\n\nfunction createStoreInternals(_ref) {\n  var disableInternalSelectFnMemoize = _ref.disableInternalSelectFnMemoize,\n      initialState = _ref.initialState,\n      injections = _ref.injections,\n      model = _ref.model,\n      reducerEnhancer = _ref.reducerEnhancer,\n      references = _ref.references;\n  var isInReducer = false;\n\n  var wrapFnWithMemoize = function wrapFnWithMemoize(x) {\n    return !disableInternalSelectFnMemoize && typeof x === 'function' ? memoizerific(maxSelectFnMemoize)(x) : x;\n  };\n\n  var defaultState = initialState || {};\n  var selectorId = 0;\n  var computedProperties = {};\n  var actionCreatorDict = {};\n  var actionCreators = {};\n  var actionListenersDict = {};\n  var actionReducersDict = {};\n  var actionThunks = {};\n  var customReducers = [];\n  var listenDefinitions = [];\n  var listenerActionDefinitions = [];\n  var listenerActionMap = {};\n  var listenerThunkMap = {};\n  var selectorsDict = {};\n  var selectorReducers = [];\n  var thunkListenersDict = {};\n\n  var recursiveExtractDefsFromModel = function recursiveExtractDefsFromModel(current, parentPath) {\n    return Object.keys(current).forEach(function (key) {\n      var value = current[key];\n      var path = [].concat(parentPath, [key]);\n      var meta = {\n        parent: parentPath,\n        path: path\n      };\n\n      if (typeof value === 'function') {\n        if (value[actionSymbol]) {\n          var name = \"@action.\" + path.join('.');\n          value[actionNameSymbol] = name;\n          value[metaSymbol] = meta; // Action Reducer\n\n          var actionReducer = value;\n          actionReducer[actionNameSymbol] = name;\n          actionReducersDict[name] = actionReducer;\n\n          var actionCreator = function actionCreator(payload) {\n            var result = references.dispatch({\n              type: actionReducer[actionNameSymbol],\n              payload: payload\n            });\n            return result;\n          };\n\n          actionCreator[actionNameSymbol] = name;\n          actionCreatorDict[name] = actionCreator;\n          set(path, actionCreators, actionCreator);\n          var config = value[actionStateSymbol].config;\n\n          if (config && config.listenTo) {\n            listenerActionDefinitions.push(value);\n          }\n        } else if (value[thunkSymbol]) {\n          var _name = \"@thunk.\" + path.join('.');\n\n          value[actionNameSymbol] = _name; // Thunk Action\n\n          var action = function action(payload) {\n            return value(get(parentPath, actionCreators), payload, {\n              // @deprecated\n              dispatch: references.dispatch,\n              getState: function getState() {\n                return get(parentPath, references.getState());\n              },\n              getStoreActions: function getStoreActions() {\n                return actionCreators;\n              },\n              getStoreState: references.getState,\n              injections: injections,\n              meta: meta\n            });\n          };\n\n          set(path, actionThunks, action); // Thunk Action Creator\n\n          var _actionCreator = function _actionCreator(payload) {\n            return tick().then(function () {\n              return references.dispatch({\n                type: _name + \"(started)\",\n                payload: payload\n              });\n            }).then(function () {\n              return references.dispatch(function () {\n                return action(payload);\n              });\n            }).then(function (result) {\n              references.dispatch({\n                type: _name + \"(completed)\",\n                payload: payload\n              });\n              return result;\n            }).catch(function (err) {\n              references.dispatch({\n                type: _name + \"(failed)\",\n                payload: payload,\n                error: errorToPayload(err)\n              });\n              throw err;\n            });\n          };\n\n          _actionCreator[actionNameSymbol] = _name;\n          actionCreatorDict[_name] = _actionCreator;\n          set(path, actionCreators, _actionCreator);\n          var _config = value[thunkStateSymbol].config;\n\n          if (_config && _config.listenTo) {\n            listenerActionDefinitions.push(value);\n          }\n        } else if (value[computedSymbol]) {\n          var target = get(parentPath, defaultState);\n\n          if (!target) {\n            target = {};\n            set(parentPath, defaultState, target);\n          }\n\n          var _config2 = value[computedConfigSymbol];\n          var stateResolvers = _config2.stateResolvers;\n          var memoisedResultFn = memoizerific(1)(value);\n          var cache;\n\n          var createComputedProperty = function createComputedProperty(o) {\n            Object.defineProperty(o, key, {\n              configurable: true,\n              get: function get$1() {\n                var storeState = isInReducer ? references.currentState : references.getState();\n                var state = get(parentPath, storeState);\n                var inputs = stateResolvers.map(function (resolver) {\n                  return resolver(state, storeState);\n                });\n                cache = memoisedResultFn.apply(void 0, inputs);\n                return cache;\n              },\n              set: function set() {\n                throw new Error(\"Easy Peasy: You attempted to set \\\"\" + path.join('.') + \"\\\", which is a computed property set a computed property\");\n              }\n            });\n          };\n\n          createComputedProperty(target);\n          set(path, computedProperties, createComputedProperty);\n        } else if (value[selectorSymbol]) {\n          selectorId += 1;\n          var selectorInstanceId = selectorId;\n          var _value$selectorConfig = value[selectorConfigSymbol],\n              args = _value$selectorConfig.args,\n              _config3 = _value$selectorConfig.config;\n          var stateSelectors = args && Array.isArray(args) ? args.map(function (s) {\n            return memoizerific(1)(s);\n          }) : [function (state) {\n            return state;\n          }];\n          var limit = typeof _config3 === 'object' && typeof _config3.limit === 'number' && _config3.limit > 0 ? _config3.number : 1;\n          var internalSelector = memoizerific(limit)(function () {\n            for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {\n              a[_key] = arguments[_key];\n            }\n\n            return value(a.slice(0, stateSelectors.length), a.slice(stateSelectors.length));\n          });\n          var changeIdx = 0;\n          /**\n           * This allows us to track whether the state we are depending on\n           * (resolved via the state selectors), has changed. If so then we know\n           * that we should create a new instance of our selector function so\n           * that updates are propagated and memoization caches are cleared.\n           */\n\n          var createDependentStateChangeTracker = function createDependentStateChangeTracker() {\n            var internalChecker = memoizerific(1)(function () {\n              changeIdx += 1;\n              return changeIdx;\n            });\n\n            var dependentStateChangeTracker = function dependentStateChangeTracker(storeState) {\n              var localState = get(parentPath, storeState);\n              var resolvedStateArgs = stateSelectors.reduce(function (acc, argSelector) {\n                acc.push(argSelector(localState, storeState));\n                return acc;\n              }, []);\n              return internalChecker.apply(void 0, resolvedStateArgs);\n            };\n\n            return dependentStateChangeTracker;\n          };\n          /**\n           * We create a function allowing us to create new selector instances.\n           * We will need this ability to reinitialise a selector of the state\n           * it depends on changes.\n           */\n\n\n          var createSelector = function createSelector() {\n            var selector = function selector() {\n              var storeState = references.getState();\n              var localState = get(parentPath, storeState);\n              var selectedStateArgs = stateSelectors.reduce(function (acc, argSelector) {\n                return [].concat(acc, [argSelector(localState, storeState)]);\n              }, []);\n\n              for (var _len2 = arguments.length, runtimeArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                runtimeArgs[_key2] = arguments[_key2];\n              }\n\n              return internalSelector.apply(void 0, selectedStateArgs.concat(runtimeArgs));\n            };\n\n            selector[selectorStateSymbol] = {\n              dependentStateChangeTracker: createDependentStateChangeTracker(),\n              createSelector: createSelector,\n              meta: meta,\n              selectorId: selectorInstanceId\n            };\n            return selector;\n          };\n\n          var selector = createSelector();\n          selectorsDict[selectorId] = selector;\n          set(path, defaultState, selector);\n        } else if (value[selectSymbol]) {\n          value[selectStateSymbol] = {\n            parentPath: parentPath,\n            key: key,\n            executed: false\n          };\n          selectorReducers.push(value);\n        } else if (value[reducerSymbol]) {\n          customReducers.push({\n            path: path,\n            reducer: value\n          });\n        } else if (value[listenSymbol]) {\n          listenDefinitions.push(value);\n          value[metaSymbol] = meta;\n        } else if (process.env.NODE_ENV !== 'production') {\n          // eslint-disable-next-line no-console\n          console.warn(\"easy-peasy: Found a function at path \" + path.join('.') + \" in your model. Version 2 required that you wrap your action functions with the \\\"action\\\" helper\");\n        }\n      } else if (isStateObject(value) && Object.keys(value).length > 0) {\n        var existing = get(path, defaultState);\n\n        if (existing == null) {\n          set(path, defaultState, {});\n        }\n\n        recursiveExtractDefsFromModel(value, path);\n      } else {\n        // State\n        var initialParentRef = get(parentPath, initialState);\n\n        if (initialParentRef && key in initialParentRef) {\n          set(path, defaultState, initialParentRef[key]);\n        } else {\n          set(path, defaultState, value);\n        }\n      }\n    });\n  };\n\n  recursiveExtractDefsFromModel(model, []);\n  listenerActionDefinitions.forEach(function (listenerAction) {\n    var _ref2 = listenerAction[actionStateSymbol] || listenerAction[thunkStateSymbol],\n        listenTo = _ref2.config.listenTo;\n\n    var targetName;\n\n    var processListenTo = function processListenTo(target) {\n      if (typeof target === 'function' && target[actionNameSymbol] && actionCreatorDict[target[actionNameSymbol]]) {\n        if (target[thunkSymbol]) {\n          targetName = thunkCompleteName(target);\n        } else {\n          targetName = target[actionNameSymbol];\n        }\n      } else if (typeof target === 'string') {\n        targetName = target;\n      }\n\n      var listenerReg = listenerActionMap[targetName] || [];\n      listenerReg.push(actionCreatorDict[listenerAction[actionNameSymbol]]);\n      listenerActionMap[targetName] = listenerReg;\n    };\n\n    if (Array.isArray(listenTo)) {\n      listenTo.forEach(processListenTo);\n    } else {\n      processListenTo(listenTo);\n    }\n  });\n  selectorReducers.forEach(function (selector) {\n    selector[selectImpSymbol] = function (state) {\n      return wrapFnWithMemoize(selector(state));\n    };\n  });\n  listenDefinitions.forEach(function (def) {\n    def.listeners = def.listeners || {};\n\n    var on = function on(target, handler) {\n      if (typeof handler !== 'function') {\n        return;\n      }\n\n      var meta = def[metaSymbol];\n      handler[metaSymbol] = meta;\n\n      if (!handler[actionSymbol] && !handler[thunkSymbol]) {\n        if (process.env.NODE_ENV !== 'production') {\n          // eslint-disable-next-line\n          console.warn(\"easy-peasy: you must provide either an \\\"action\\\" or \\\"thunk\\\" to your listeners. Found an invalid handler at \\\"\" + meta.path.join('.') + \"\\\"\");\n        }\n\n        return;\n      }\n\n      var targetActionName;\n\n      if (typeof target === 'function' && target[actionNameSymbol] && actionCreatorDict[target[actionNameSymbol]]) {\n        if (target[thunkSymbol]) {\n          targetActionName = thunkCompleteName(target);\n        } else {\n          targetActionName = target[actionNameSymbol];\n        }\n      } else if (typeof target === 'string') {\n        targetActionName = target;\n      }\n\n      if (targetActionName) {\n        if (handler[thunkSymbol]) {\n          thunkListenersDict[targetActionName] = thunkListenersDict[targetActionName] || [];\n          thunkListenersDict[targetActionName].push(handler);\n        } else {\n          actionListenersDict[targetActionName] = actionListenersDict[targetActionName] || [];\n          actionListenersDict[targetActionName].push({\n            path: meta.parent,\n            handler: handler\n          });\n        }\n\n        def.listeners[targetActionName] = def.listeners[targetActionName] || [];\n        def.listeners[targetActionName].push(handler);\n      }\n    };\n\n    def(on);\n  });\n\n  var runSelectorReducer = function runSelectorReducer(state, selector) {\n    var _selector$selectState = selector[selectStateSymbol],\n        parentPath = _selector$selectState.parentPath,\n        key = _selector$selectState.key,\n        executed = _selector$selectState.executed;\n\n    if (executed) {\n      return state;\n    }\n\n    var dependencies = selector[selectDependenciesSymbol];\n    var stateAfterDependencies = dependencies ? dependencies.reduce(runSelectorReducer, state) : state;\n    var newState = stateAfterDependencies;\n\n    if (parentPath.length > 0) {\n      var target = get(parentPath, stateAfterDependencies);\n\n      if (target) {\n        if (!selector.prevState || selector.prevState !== get(parentPath, state)) {\n          var newValue = selector[selectImpSymbol](target);\n          newState = produce(state, function (draft) {\n            var updateTarget = get(parentPath, draft);\n            updateTarget[key] = newValue;\n          });\n          selector.prevState = get(parentPath, newState);\n        }\n      }\n    } else if (!selector.prevState || selector.prevState !== state) {\n      var _newValue = selector[selectImpSymbol](stateAfterDependencies);\n\n      newState = produce(state, function (draft) {\n        draft[key] = _newValue;\n      });\n      selector.prevState = newState;\n    }\n\n    selector[selectStateSymbol].executed = true;\n    return newState;\n  };\n\n  var runSelectors = function runSelectors(state) {\n    return selectorReducers.reduce(runSelectorReducer, state);\n  };\n\n  var createReducer = function createReducer() {\n    var runActionReducerAtPath = function runActionReducerAtPath(state, action, actionReducer, path) {\n      var current = get(path, state);\n      var updatedState = path.length === 0 ? produce(state, function (_draft) {\n        return actionReducer(_draft, action.payload);\n      }) : produce(state, function (draft) {\n        set(actionReducer[metaSymbol].parent, draft, produce(current, function (_draft) {\n          return actionReducer(_draft, action.payload);\n        }));\n      });\n\n      if (updatedState !== state) {\n        var computedPropertyCreators = get(path, computedProperties);\n\n        if (computedPropertyCreators) {\n          var updatedCurrent = get(path, updatedState);\n          Object.keys(computedPropertyCreators).forEach(function (key) {\n            computedPropertyCreators[key](updatedCurrent);\n          });\n        }\n      }\n\n      return updatedState;\n    };\n\n    var reducerForActions = function reducerForActions(state, action) {\n      var actionReducer = actionReducersDict[action.type];\n\n      if (actionReducer) {\n        return runActionReducerAtPath(state, action, actionReducer, actionReducer[metaSymbol].parent);\n      }\n\n      return state;\n    };\n\n    var reducerForListeners = function reducerForListeners(state, action) {\n      var target = action.type === '@@EP/LISTENER' ? action.actionName : action.type;\n      var actionListeners = actionListenersDict[target];\n\n      if (actionListeners) {\n        var targetAction = action.type === '@@EP/LISTENER' ? {\n          type: target,\n          payload: action.payload\n        } : action;\n        return actionListeners.reduce(function (newState, _ref3) {\n          var path = _ref3.path,\n              handler = _ref3.handler;\n          return runActionReducerAtPath(newState, targetAction, handler, path);\n        }, state);\n      }\n\n      return state;\n    };\n\n    var reducerForCustomReducers = function reducerForCustomReducers(state, action) {\n      return produce(state, function (draft) {\n        customReducers.forEach(function (_ref4) {\n          var p = _ref4.path,\n              red = _ref4.reducer;\n          var current = get(p, draft);\n          set(p, draft, red(current, action));\n        });\n      });\n    };\n\n    var isInitial = true;\n\n    var selectsReducer = function selectsReducer(state) {\n      var stateAfterSelectors = runSelectors(state);\n      isInitial = false;\n      selectorReducers.forEach(function (selector) {\n        selector[selectStateSymbol].executed = false;\n      });\n      return stateAfterSelectors;\n    };\n\n    var selectorsReducer = function selectorsReducer(state) {\n      var selectors = Object.values(selectorsDict);\n      return produce(state, function (draft) {\n        selectors.forEach(function (selector) {\n          var selectorState = selector[selectorStateSymbol];\n\n          if (selectorState.prevStateCheckId == null) {\n            selectorState.prevStateCheckId = selectorState.dependentStateChangeTracker(state);\n          } else {\n            var nextStateCheckId = selectorState.dependentStateChangeTracker(state);\n\n            if (selectorState.prevStateCheckId !== nextStateCheckId) {\n              var newSelector = selectorState.createSelector();\n              newSelector[selectorState.prevStateCheckId] = nextStateCheckId;\n              selectorsDict[selectorState.selectorId] = newSelector;\n              set(selectorState.meta.path, draft, newSelector);\n            }\n          }\n        });\n      });\n    };\n\n    var rootReducer = function rootReducer(state, action) {\n      isInReducer = true;\n      var stateAfterActions = reducerForActions(state, action);\n      var stateAfterListeners = reducerForListeners(stateAfterActions, action);\n      var stateAfterCustomReducers = reducerForCustomReducers(stateAfterListeners, action);\n      var stateAfterSelect = state !== stateAfterCustomReducers || isInitial ? selectsReducer(stateAfterCustomReducers) : stateAfterCustomReducers;\n      var result = selectorsReducer(stateAfterSelect);\n      isInReducer = false;\n      return result;\n    };\n\n    return rootReducer;\n  };\n\n  return {\n    actionCreators: actionCreators,\n    actionListenersDict: actionListenersDict,\n    defaultState: defaultState,\n    listenDefinitions: listenDefinitions,\n    listenerActionMap: listenerActionMap,\n    listenerThunkMap: listenerThunkMap,\n    reducer: reducerEnhancer(createReducer()),\n    thunkListenersDict: thunkListenersDict\n  };\n}\n\nfunction createStore(model, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      compose$1 = _options.compose,\n      _options$devTools = _options.devTools,\n      devTools = _options$devTools === void 0 ? true : _options$devTools,\n      _options$disableInter = _options.disableInternalSelectFnMemoize,\n      disableInternalSelectFnMemoize = _options$disableInter === void 0 ? false : _options$disableInter,\n      _options$enhancers = _options.enhancers,\n      enhancers = _options$enhancers === void 0 ? [] : _options$enhancers,\n      _options$initialState = _options.initialState,\n      initialState = _options$initialState === void 0 ? {} : _options$initialState,\n      injections = _options.injections,\n      _options$middleware = _options.middleware,\n      middleware = _options$middleware === void 0 ? [] : _options$middleware,\n      _options$mockActions = _options.mockActions,\n      mockActions = _options$mockActions === void 0 ? false : _options$mockActions,\n      _options$name = _options.name,\n      storeName = _options$name === void 0 ? \"EasyPeasyStore\" : _options$name,\n      _options$reducerEnhan = _options.reducerEnhancer,\n      reducerEnhancer = _options$reducerEnhan === void 0 ? function (rootReducer) {\n    return rootReducer;\n  } : _options$reducerEnhan;\n\n  var modelDefinition = _extends({}, model, {\n    logFullState: thunk(function (actions, payload, _ref) {\n      var getState = _ref.getState; // eslint-disable-next-line no-console\n\n      console.log(JSON.stringify(getState(), null, 2));\n    }),\n    replaceState: action(function (state, payload) {\n      return payload;\n    })\n  });\n\n  var references = {};\n  var mockedActions = [];\n\n  var dispatchThunk = function dispatchThunk(thunk, payload) {\n    return thunk(get(thunk[metaSymbol].parent, references.internals.actionCreators), payload, {\n      dispatch: references.dispatch,\n      getState: function getState() {\n        return get(thunk[metaSymbol].parent, references.getState());\n      },\n      getStoreState: references.getState,\n      injections: injections,\n      meta: thunk[metaSymbol]\n    });\n  };\n\n  var dispatchThunkListeners = function dispatchThunkListeners(name, payload) {\n    var listensForAction = references.internals.thunkListenersDict[name];\n    return listensForAction && listensForAction.length > 0 ? Promise.all(listensForAction.map(function (listenForAction) {\n      return dispatchThunk(listenForAction, payload);\n    })) : Promise.resolve();\n  };\n\n  var dispatchActionStringListeners = function dispatchActionStringListeners() {\n    return function (next) {\n      return function (action) {\n        var result = next(action);\n\n        if (references.internals.thunkListenersDict[action.type]) {\n          dispatchThunkListeners(action.type, action.payload);\n        }\n\n        return result;\n      };\n    };\n  };\n\n  var composeEnhancers = compose$1 || (devTools && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({\n    name: storeName\n  }) : compose);\n\n  var bindStoreInternals = function bindStoreInternals(state) {\n    references.internals = createStoreInternals({\n      disableInternalSelectFnMemoize: disableInternalSelectFnMemoize,\n      initialState: state,\n      injections: injections,\n      model: modelDefinition,\n      reducerEnhancer: reducerEnhancer,\n      references: references\n    });\n  };\n\n  bindStoreInternals(initialState);\n\n  var listenerActionsMiddleware = function listenerActionsMiddleware() {\n    return function (next) {\n      return function (action) {\n        var result = next(action);\n\n        if (action && references.internals.listenerActionMap[action.type] && references.internals.listenerActionMap[action.type].length > 0) {\n          references.internals.listenerActionMap[action.type].forEach(function (actionCreator) {\n            actionCreator(action.payload);\n          });\n        }\n\n        return result;\n      };\n    };\n  };\n\n  var mockActionsMiddleware = function mockActionsMiddleware() {\n    return function (next) {\n      return function (action) {\n        if (mockActions) {\n          if (action == null || typeof action === 'object' && action.type === '@@EP/LISTENER') ;else {\n            mockedActions.push(action);\n          }\n          return undefined;\n        }\n\n        return next(action);\n      };\n    };\n  };\n\n  var currentStateMiddleware = function currentStateMiddleware() {\n    return function (next) {\n      return function (action) {\n        references.currentState = references.getState();\n        return next(action);\n      };\n    };\n  };\n\n  var store = createStore$1(references.internals.reducer, references.internals.defaultState, composeEnhancers.apply(void 0, [applyMiddleware.apply(void 0, [reduxThunk, dispatchActionStringListeners].concat(middleware, [listenerActionsMiddleware, currentStateMiddleware, mockActionsMiddleware]))].concat(enhancers)));\n\n  store.getMockedActions = function () {\n    return [].concat(mockedActions);\n  };\n\n  store.clearMockedActions = function () {\n    mockedActions = [];\n  };\n\n  references.dispatch = store.dispatch;\n  references.getState = store.getState; // attach the action creators to dispatch\n\n  var bindActionCreators = function bindActionCreators(actionCreators) {\n    Object.keys(store.dispatch).forEach(function (actionsKey) {\n      delete store.dispatch[actionsKey];\n    });\n    Object.keys(actionCreators).forEach(function (key) {\n      store.dispatch[key] = actionCreators[key];\n    });\n\n    store.getActions = function () {\n      return actionCreators;\n    };\n  };\n\n  bindActionCreators(references.internals.actionCreators);\n\n  var rebindStore = function rebindStore(removeKey) {\n    var currentState = store.getState();\n\n    if (removeKey) {\n      delete currentState[removeKey];\n    }\n\n    bindStoreInternals(store.getState());\n    store.replaceReducer(references.internals.reducer);\n    store.dispatch.replaceState(references.internals.defaultState);\n    bindActionCreators(references.internals.actionCreators);\n  };\n\n  store.addModel = function (key, modelForKey) {\n    if (modelDefinition[key] && process.env.NODE_ENV !== 'production') {\n      // eslint-disable-next-line no-console\n      console.warn(\"easy-peasy: The store model already contains a model definition for \\\"\" + key + \"\\\"\");\n      store.removeModel(key);\n    }\n\n    modelDefinition[key] = modelForKey;\n    rebindStore();\n  };\n\n  store.removeModel = function (key) {\n    if (!modelDefinition[key]) {\n      if (process.env.NODE_ENV !== 'production') {\n        // eslint-disable-next-line no-console\n        console.warn(\"easy-peasy: The store model does not contain a model definition for \\\"\" + key + \"\\\"\");\n      }\n\n      return;\n    }\n\n    delete modelDefinition[key];\n    rebindStore(key);\n  }; // @deprecated\n\n\n  var dispatchActionListener = function dispatchActionListener(actionName, payload) {\n    return store.dispatch({\n      type: '@@EP/LISTENER',\n      payload: payload,\n      actionName: actionName\n    });\n  };\n\n  var resolveActionName = function resolveActionName(action) {\n    return typeof action === 'function' ? action[actionSymbol] ? actionName(action) : action[thunkSymbol] ? thunkCompleteName(action) : undefined : typeof action === 'string' ? action : undefined;\n  }; // @deprecated\n\n\n  store.triggerListener = function (listener, action, payload) {\n    var actionName = resolveActionName(action);\n\n    if (listener.listeners[actionName] && listener.listeners[actionName].length > 0) {\n      if (listener.listeners[actionName].some(function (handler) {\n        return handler[actionSymbol];\n      })) {\n        dispatchActionListener(actionName, payload);\n      }\n\n      var thunkHandlers = listener.listeners[actionName].filter(function (handler) {\n        return handler[thunkSymbol];\n      });\n      return thunkHandlers.length > 0 ? Promise.all(thunkHandlers.map(function (handler) {\n        return dispatchThunk(handler, payload);\n      })).then(function () {\n        return undefined;\n      }) : Promise.resolve();\n    }\n\n    return Promise.resolve();\n  }; // @deprecated\n\n\n  store.triggerListeners = function (action, payload) {\n    var actionName = resolveActionName(action);\n\n    if (actionName) {\n      var actionListenerHandlers = references.internals.actionListenersDict[actionName];\n\n      if (actionListenerHandlers && actionListenerHandlers.length > 0) {\n        dispatchActionListener(actionName, payload);\n      }\n\n      var thunkListenerHandlers = references.internals.thunkListenersDict[actionName];\n      return thunkListenerHandlers && thunkListenerHandlers.length > 0 ? Promise.all(thunkListenerHandlers.map(function (handler) {\n        return dispatchThunk(handler, payload);\n      })).then(function () {\n        return undefined;\n      }) : Promise.resolve();\n    }\n\n    return Promise.resolve();\n  };\n\n  store.useStoreActions = useStoreActions;\n  store.useStoreDispatch = useStoreDispatch;\n  store.useStoreState = useStoreState;\n  return store;\n}\n/* eslint-disable react/prop-types */\n\n\nfunction createContextStore(model, config) {\n  var StoreContext = createContext();\n\n  function Provider(_ref) {\n    var children = _ref.children,\n        initialData = _ref.initialData;\n    var store = useMemo(function () {\n      return createStore(typeof model === 'function' ? model(initialData) : model, config);\n    }, []);\n    return React.createElement(StoreContext.Provider, {\n      value: store\n    }, children);\n  }\n\n  function useStore() {\n    return useContext(StoreContext);\n  }\n\n  return {\n    Provider: Provider,\n    useStore: useStore,\n    useStoreState: createStoreStateHook(StoreContext),\n    useStoreActions: createStoreActionsHook(StoreContext),\n    useStoreDispatch: createStoreDispatchHook(StoreContext)\n  };\n}\n/**\n * Some good references on the topic of reinitialisation:\n * - https://github.com/facebook/react/issues/14830\n */\n\n\nfunction createComponentStore(model, config) {\n  return function useLocalStore(initialData) {\n    var store = useMemo(function () {\n      return createStore(typeof model === 'function' ? model(initialData) : model, config);\n    }, []);\n    var previousStateRef = useRef(store.getState());\n\n    var _useState = useState(function () {\n      return store.getState();\n    }),\n        currentState = _useState[0],\n        setCurrentState = _useState[1];\n\n    useEffect(function () {\n      return store.subscribe(function () {\n        var nextState = store.getState();\n\n        if (previousStateRef.current !== nextState) {\n          previousStateRef.current = nextState;\n          setCurrentState(nextState);\n        }\n      });\n    }, [store]);\n    return [currentState, store.dispatch];\n  };\n}\n\nvar StoreProvider = function StoreProvider(_ref) {\n  var children = _ref.children,\n      store = _ref.store;\n  return React.createElement(StoreContext.Provider, {\n    value: store\n  }, children);\n};\n/**\n * immer is an implementation detail, so we are not going to use its auto freeze\n * behaviour, which throws errors if trying to mutate state. It's also risky\n * for production builds as has a perf overhead.\n *\n * @see https://github.com/mweststrate/immer#auto-freezing\n */\n\n\nsetAutoFreeze(false);\nexport { StoreProvider, action, actionName, computed, createComponentStore, createContextStore, createStore, createTypedHooks, debug, listen, memo, reducer, select, selector, thunk, thunkCompleteName, thunkFailName, thunkStartName, useActions, useDispatch, useStore, useStoreActions, useStoreDispatch, useStoreState };","map":null,"metadata":{},"sourceType":"module"}